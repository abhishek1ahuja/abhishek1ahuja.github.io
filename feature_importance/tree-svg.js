

const treeData = [{'name': 'perimeter_worst', 'imp_value': 0.1552559309691913, 'value': 31.095283462431723, 'level': 0, 'features': ['f8', 'f21', 'f23', 'f24', 'f28'], 'children': [{'name': 'radius_worst', 'imp_value': 0.14610009045443323, 'value': 28.807883278982356, 'level': 1, 'features': ['f8', 'f21', 'f24', 'f28'], 'type': 'with', 'children': [{'name': 'area_worst', 'imp_value': 0.1677517737706833, 'value': 34.21711515777581, 'level': 2, 'features': ['f8', 'f24', 'f28'], 'type': 'with', 'children': [{'name': 'concave points_worst', 'imp_value': 0.16051097248528895, 'value': 32.40814850290293, 'level': 3, 'features': ['f8', 'f28'], 'type': 'with', 'children': [{'name': 'concave points_mean', 'imp_value': 0.23092636714694367, 'value': 50.0, 'level': 4, 'features': ['f8'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.1756155663440527, 'value': 36.1817234912149, 'level': 4, 'features': ['f8', 'f28'], 'type': 'without'}]}, {'name': 'concave points_worst', 'imp_value': 0.16972557194834093, 'value': 34.71022841224859, 'level': 3, 'features': ['f8', 'f24', 'f28'], 'type': 'without', 'children': [{'name': 'concave points_mean', 'imp_value': 0.14685452607713953, 'value': 28.99636364613134, 'level': 4, 'features': ['f8', 'f24'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.12531265670560507, 'value': 23.614566543739123, 'level': 4, 'features': ['f8', 'f24', 'f28'], 'type': 'without'}]}]}, {'name': 'area_worst', 'imp_value': 0.15511803583743705, 'value': 31.060833173661074, 'level': 2, 'features': ['f8', 'f21', 'f24', 'f28'], 'type': 'without', 'children': [{'name': 'concave points_worst', 'imp_value': 0.1324870981482266, 'value': 25.40695454411408, 'level': 3, 'features': ['f8', 'f21', 'f28'], 'type': 'with', 'children': [{'name': 'concave points_mean', 'imp_value': 0.17586646554525256, 'value': 36.2444055440452, 'level': 4, 'features': ['f8', 'f21'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.16425045530095816, 'value': 33.34238208471119, 'level': 4, 'features': ['f8', 'f21', 'f28'], 'type': 'without'}]}, {'name': 'concave points_worst', 'imp_value': 0.10315674960083988, 'value': 18.079364625986386, 'level': 3, 'features': ['f8', 'f21', 'f24', 'f28'], 'type': 'without', 'children': [{'name': 'concave points_mean', 'imp_value': 0.1799475018585276, 'value': 37.263969307372236, 'level': 4, 'features': ['f8', 'f21', 'f24'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.1322632114556018, 'value': 25.3510210161156, 'level': 4, 'features': ['f8', 'f21', 'f24', 'f28'], 'type': 'without'}]}]}]}, {'name': 'radius_worst', 'imp_value': 0.13555117703810868, 'value': 26.172452217814524, 'level': 1, 'features': ['f8', 'f21', 'f23', 'f24', 'f28'], 'type': 'without', 'children': [{'name': 'area_worst', 'imp_value': 0.124170524712876, 'value': 23.32922813865432, 'level': 2, 'features': ['f8', 'f23', 'f24', 'f28'], 'type': 'with', 'children': [{'name': 'concave points_worst', 'imp_value': 0.13553038654705735, 'value': 26.167258137274548, 'level': 3, 'features': ['f8', 'f23', 'f28'], 'type': 'with', 'children': [{'name': 'concave points_mean', 'imp_value': 0.1791779450888787, 'value': 37.07171122978424, 'level': 4, 'features': ['f8', 'f23'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.10695070791876758, 'value': 19.027207801983035, 'level': 4, 'features': ['f8', 'f23', 'f28'], 'type': 'without'}]}, {'name': 'concave points_worst', 'imp_value': 0.1448344631395149, 'value': 28.491692084120853, 'level': 3, 'features': ['f8', 'f23', 'f24', 'f28'], 'type': 'without', 'children': [{'name': 'concave points_mean', 'imp_value': 0.11253397376661618, 'value': 20.422073003493477, 'level': 4, 'features': ['f8', 'f23', 'f24'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.10191817162952542, 'value': 17.76993115843806, 'level': 4, 'features': ['f8', 'f23', 'f24', 'f28'], 'type': 'without'}]}]}, {'name': 'area_worst', 'imp_value': 0.12275851287603175, 'value': 22.97646575387663, 'level': 2, 'features': ['f8', 'f21', 'f23', 'f24', 'f28'], 'type': 'without', 'children': [{'name': 'concave points_worst', 'imp_value': 0.14246859212779198, 'value': 27.900627421350723, 'level': 3, 'features': ['f8', 'f21', 'f23', 'f28'], 'type': 'with', 'children': [{'name': 'concave points_mean', 'imp_value': 0.13491663567471326, 'value': 26.01392498826118, 'level': 4, 'features': ['f8', 'f21', 'f23'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.09911832748829723, 'value': 17.070447152359975, 'level': 4, 'features': ['f8', 'f21', 'f23', 'f28'], 'type': 'without'}]}, {'name': 'concave points_worst', 'imp_value': 0.1284809701913007, 'value': 24.406105107208383, 'level': 3, 'features': ['f8', 'f21', 'f23', 'f24', 'f28'], 'type': 'without', 'children': [{'name': 'concave points_mean', 'imp_value': 0.14479876390840896, 'value': 28.482773358674606, 'level': 4, 'features': ['f8', 'f21', 'f23', 'f24'], 'type': 'with'}, {'name': 'concave points_mean', 'imp_value': 0.07081725146170863, 'value': 10.0, 'level': 4, 'features': ['f8', 'f21', 'f23', 'f24', 'f28'], 'type': 'without'}]}]}]}]}
];

      // ************** Generate the tree diagram  *****************
  var Names = ['perimeter_worst',
 'radius_worst',
 'area_worst',
 'concave points_worst',
 'concave points_mean']

  var margin = { top: 50, right: 0, bottom: 0, left: 100 },
  width = 800 - margin.right - margin.left,
  height = 1000 - margin.top - margin.bottom;
  
  var i = 0,
  duration = 750,
  root;
  
  var tree = d3.layout.tree()
  .size([height, width]);
  
  var diagonal = d3.svg.diagonal()
  .projection(function (d) { return [d.x, d.y]; });

  var svg = d3.select("#treechart").append("svg")
  .attr("width", width + margin.right + margin.left)
  .attr("height", height + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "scale(0.75) translate(" + margin.left + "," + margin.top + ")"); 

  root = treeData[0];
  root.x0 = height / 2;
  root.y0 = 0;
  
  update(root);
  
  d3.select(self.frameElement).style("height", "500px");
  var p;
  for (p=0; p<Names.length; p++) {
    svg.append("text").attr("x", -100).attr("y", 0 + p * 140).text(Names[p]).style("font-size", "17px");
  } 

// Handmade legend
svg.append("circle").attr("cx",340).attr("cy",696).attr("r", 6).style("fill", "#ccc").style("stroke", "lightsteelblue")
svg.append("circle").attr("cx",340).attr("cy",726).attr("r", 6).style("fill", "lightsteelblue").style("stroke", "lightsteelblue")
svg.append("text").attr("x", 380).attr("y", 700).text("without previous node").style("font-size", "17px").attr("alignment-baseline","middle").attr("width",200)
svg.append("text").attr("x", 380).attr("y", 730).text("with previous node").style("font-size", "17px").attr("alignment-baseline","middle").attr("width",200)

  
  function update(source) {



        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
        links = tree.links(nodes);

        // Normalize for fixed-depth.
        nodes.forEach(function (d) { d.y = d.depth * 140;});

        // Update the nodes…
        var node = svg.selectAll("g.node")
        .data(nodes, function (d) {
          return d.id || (d.id = ++i);
        });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node.enter().append("g")
        .attr("class", "node")
        .attr("transform", function (d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
        .on("click", click);


        nodeEnter.append("circle")
        .attr("r", 1e-6)
          .attr("id", function (d) { return "node" + d.id; })//id of the node.
          //.style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; })
          .attr("fill-opacity", "0.8")

          .style("fill", function (d) {
            // if(d.type == "without") return "lightsteelblue";
         return "lightsteelblue";
          });

          nodeEnter.append("text")
          .attr("x", function (d) { return d.children || d._children ? -20 : 20; })
          .attr("dy", ".35em")
          .attr("text-anchor", function (d) { return d.children || d._children ? "end" : "start"; })

          //.text(function (d) { return d.name; })
          .style("fill-opacity", 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate = node.transition()
        .duration(duration)
        .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; });

        nodeUpdate.select("circle")
        .attr("r", function (d) { return d.value / 2; })
        .attr("fill-opacity", "0.8")
          //.style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
          .style("fill", function (d) {
            // if(d.type == "without") return "red";
          return "white";
          });

          nodeUpdate.select("text")
          .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function (d) { return "translate(" + source.x + "," + source.y + ")"; })
        .remove();

        nodeExit.select("circle")
        .attr("r", 1e-6);

        nodeExit.select("text")
        .style("fill-opacity", 1e-6);

        // Update the links…
        var link = svg.selectAll("path.link")
        .data(links, function (d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
        .attr("class", "link")
          .attr("id", function (d) { return ("link" + d.source.id + "-" + d.target.id) })//unique id
          .style("stroke-width", function (d) {
            // return 3;
            return (d.target.value) / 3;
          })
          .attr("d", function (d) {
            var o = { x: source.x0, y: source.y0 };
            return diagonal({ source: o, target: o });
          })
          .style("stroke",function(d){
            if (d.target.type == "with") {
              
              return "#bacee8" 

            }else {
              return "#ccc"; 
            }
          });



          link.on("mouseover",function(d){ 

            tippy_content = "<span style='font-weight:900'>" + d.target.type + " " + d.source.name;
 

            if (this._tippy == null) {
              tippy(this, {
                allowHTML: true,
                followCursor: true,
                content: tippy_content,
                size: "large",
                arrow: true,
              });
            }

          });
          
          
          node.on("mouseover", function (d) { 
          d3.select(this).style("fill", "red") // colour hovered over text red
          for(i=0; i<Names.length; i++) {
            if (d.name ==  Names[i]) {
              interaction(d.name);


            }
          }
            tippy_content = "<span style='font-weight:900'> Value: " +
            d.value;

          while (d.parent) {
            //d3.selectAll("#node"+d.id).style("fill", "red");//color the node
            if (d.parent != "null")
              d3.selectAll("#link" + d.parent.id + "-" + d.id).style("stroke", "orange");//color the path
            d = d.parent;
          }
          //node.ancestors.attr("price", 3);

         
            if (this._tippy == null) {
              tippy(this, {
                allowHTML: true,
                followCursor: true,
                content: tippy_content,
                size: "large",
                arrow: true,
              });
            }

        }).on("mouseout", function (d) {
          node.style("fill", "black")
          interactionoff();
          //d3.selectAll("#node"+d.id).style("fill", "white");//color the node white after unhover
          //d3.select(this).style("fill", "black")
          link.style("stroke",function(d){
            if (d.target.type == "with") {
              
              return "#bacee8" 

            }else {
              return "#ccc"; 
            }
          });


        })


        // Transition links to their new position.
        link.transition()
        .duration(duration)
        .attr("d", diagonal);


        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
        .duration(duration)
        .attr("d", function (d) {
          var o = { x: source.x, y: source.y };
          return diagonal({ source: o, target: o });
        })
        .remove();

        // Stash the old positions for transition.
        nodes.forEach(function (d) {
          d.x0 = d.x;
          d.y0 = d.y;
        });
      }
      // Toggle children on click.
      function click(d) {
        console.log("click");
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else {
          d.children = d._children;
          d._children = null;
        }

        update(d);
      }

      
      var svg = d3.select("#my_dataviz")



